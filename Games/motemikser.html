<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Motemikser</title>
    <style>
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #ffa2ef;
        }

        #gameContainer {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        #reloadButton {
            position: absolute;
            top: 50%;
            right: 30%;
            padding: 5px 10px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="background"></div>
    <button id="reloadButton" onclick="location.reload()">Reload</button>
    <div id="gameContainer"></div>

</body>
<script type="module">
import { Game, GameObject, GameObjects } from './GameEngine.js';

const Color = {
    NONE: 0,
    RED: 1,
    GREEN: 2,
    BLUE: 3,
    YELLOW: 4,
};

class Cell extends GameObject {
    constructor(color, row, col) {
        super();
        this.color = color;
        this.row = row;
        this.col = col;
        this.cellSize = 40;
        this.width = this.cellSize;
        this.height = this.cellSize;
    }

    setPosition(row, col) {
        this.row = row;
        this.col = col;
    }

    draw(context) {
        switch (this.color) {
            case Color.NONE:
                context.fillStyle = 'rgba(255, 255, 255, 0.5)';
                break;
            case Color.RED:
                context.fillStyle = 'red';
                break;
            case Color.GREEN:
                context.fillStyle = 'green';
                break;
            case Color.BLUE:
                context.fillStyle = 'blue';
                break;
            case Color.YELLOW:
                context.fillStyle = 'yellow';
                break;
        }

        context.fillRect(this.col * this.cellSize, this.row * this.cellSize, this.cellSize, this.cellSize);
        context.strokeStyle = 'black';
        context.strokeRect(this.col * this.cellSize, this.row * this.cellSize, this.cellSize, this.cellSize);
    }

    containsPoint(x, y) {
        return x >= this.col * this.cellSize && x <= (this.col + 1) * this.cellSize &&
            y >= this.row * this.cellSize && y <= (this.row + 1) * this.cellSize;
    }

    onClick(x, y) {
        if (this.parent) {
            this.parent.cellClicked(this);
        }
    }
}

class Grid extends GameObject {
    constructor(game) {
        super();
        this.game = game;
        this.cellSize = 40;
        this.numRows = Math.floor(game.canvas.height / this.cellSize);
        this.numCols = Math.floor(game.canvas.width / this.cellSize);
        this.grid = [];
        this.initGrid();
        this.hasBeenClicked = false;
    }

    initGrid() {
        for (let i = 0; i < this.numRows; i++) {
            this.grid[i] = [];
            for (let j = 0; j < this.numCols; j++) {
                const cell = new Cell(
                    Math.floor(Math.random() * (Object.keys(Color).length - 1) + 1),
                    i,
                    j
                );
                cell.parent = this;
                this.grid[i][j] = cell;
            }
        }
    }

    draw(context) {
        for (let i = 0; i < this.numRows; i++) {
            for (let j = 0; j < this.numCols; j++) {
                this.grid[i][j].draw(context);
            }
        }
    }

    update() {
        if (this.hasBeenClicked) {
            this.hasBeenClicked = false;

            // Apply gravity to make cells fall down in each column
            for (let i = 0; i < this.numCols; i++) {
                let newCol = [];
                for (let j = 0; j < this.numRows; j++) {
                    if (this.grid[j][i].color !== Color.NONE) {
                        newCol.push(this.grid[j][i]);
                    }
                }

                let row = this.numRows - 1;
                for (let cell of newCol.reverse()) {
                    cell.setPosition(row, i);
                    this.grid[row][i] = cell;
                    row--;
                }

                for (; row >= 0; row--) {
                    const emptyCell = new Cell(Color.NONE, row, i);
                    emptyCell.parent = this;
                    this.grid[row][i] = emptyCell;
                }
            }

            // Shift columns to the right if a column is empty
            for (let i = 0; i < this.numCols; i++) {
                let isEmptyColumn = true;
                for (let j = 0; j < this.numRows; j++) {
                    if (this.grid[j][i].color !== Color.NONE) {
                        isEmptyColumn = false;
                        break;
                    }
                }

                if (isEmptyColumn) {
                    for (let k = i; k > 0; k--) {
                        for (let j = 0; j < this.numRows; j++) {
                            const cell = this.grid[j][k - 1];
                            cell.setPosition(j, k);
                            this.grid[j][k] = cell;
                        }
                    }

                    for (let j = 0; j < this.numRows; j++) {
                        const emptyCell = new Cell(Color.NONE, j, 0);
                        emptyCell.parent = this;
                        this.grid[j][0] = emptyCell;
                    }
                }
            }
        }
    }

    containsPoint(x, y) {
        return x >= 0 && x <= this.numCols * this.cellSize &&
            y >= 0 && y <= this.numRows * this.cellSize;
    }

    onClick(x, y) {
        this.hasBeenClicked = true;
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);

        if (row >= 0 && row < this.numRows && col >= 0 && col < this.numCols) {
            const cell = this.grid[row][col];
            if (cell) {
                cell.onClick(x, y);
            }
        }
    }

    cellClicked(cell) {
        console.log(`Clicked cell at row: ${cell.row}, col: ${cell.col}`);
        const connectedGroup = findConnectedCells(this.grid, cell.row, cell.col);
        if (connectedGroup?.cells.length > 1) {
            for (const { row, col } of connectedGroup.cells) {
                this.grid[row][col] = new Cell(Color.NONE, row, col);
            }
        }
    }
}

function findConnectedCells(grid, startRow, startCol) {
    const targetColor = grid[startRow][startCol]?.color;
    if (targetColor === Color.NONE) return null;

    const connectedGroup = { cells: [] };
    const stack = [[startRow, startCol]];
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    while (stack.length) {
        const [row, col] = stack.pop();
        if (grid[row][col]?.color === targetColor) {
            connectedGroup.cells.push({ row, col });
            grid[row][col].color = Color.NONE;
            directions.forEach(([dr, dc]) => {
                const newRow = row + dr, newCol = col + dc;
                if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {
                    stack.push([newRow, newCol]);
                }
            });
        }
    }

    return connectedGroup;
}

const game = new Game({ width: 400, height: 400, parentElementId: 'gameContainer' }, game => game.addGameObject(new Grid(game)));
game.start();
</script>
</html>
